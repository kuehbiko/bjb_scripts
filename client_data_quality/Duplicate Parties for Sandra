{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d8fa32fe",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from pandas import ExcelWriter\n",
    "import time\n",
    "from datetime import datetime\n",
    "import datetime as dt\n",
    "import warnings\n",
    "warnings.simplefilter(\"ignore\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "c1d06112",
   "metadata": {},
   "outputs": [],
   "source": [
    "# output file: NP_InconsistencyYYMMDD.xlsx\n",
    "current_date = time.strftime(\"%Y%m%d\")\n",
    "report_name = 'NP_Inconsistency_' + current_date\n",
    "#change path below to folder you would like to save the output file\n",
    "drive_letter = r'..\\Python Scripts\\\\'\n",
    "folder_to_save_files = drive_letter + report_name + '.xlsx'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "eec2e880",
   "metadata": {},
   "outputs": [],
   "source": [
    "# import the party_data.xlsx\n",
    "file_path = r'108536_Report_2.xlsx'\n",
    "sheet_name = '108536 Report'\n",
    "df = pd.read_excel(file_path, sheet_name = sheet_name, na_filter = False)\n",
    "# filter for individuals\n",
    "df_natural = df[df['Party Type']=='Natural Person']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "7329e3f9",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Preprocessing of party name\n",
    "df_natural.loc[:,'Party Name_pre']=df_natural['Party Name'].copy()\n",
    "df_natural['Party Name_pre'] = df_natural['Party Name_pre'].str.strip()\n",
    "df_natural['Party Name_pre'] = df_natural['Party Name_pre'].str.replace(\".\",\"\")\n",
    "df_natural['Party Name_pre'] = df_natural['Party Name_pre'].str.replace(\" \",\"\")\n",
    "df_natural['Party Name_pre'] = df_natural['Party Name_pre'].str.replace('\\t','')\n",
    "df_natural['Party Name_pre'] = df_natural['Party Name_pre'].str.replace(\",\",\"\")\n",
    "df_natural['Party Name_pre'] = df_natural['Party Name_pre'].str.lower()\n",
    "\n",
    "#Prepocessing 'Identification Document Number' to remove space & casing\n",
    "df_natural.loc[:,'Identification Document Number_pre']=df_natural['Identification Document Number'].copy()\n",
    "df_natural['Identification Document Number_pre'] = df_natural['Identification Document Number_pre'].str.replace(\".\",\"\")\n",
    "df_natural['Identification Document Number_pre'] = df_natural['Identification Document Number_pre'].str.replace(\" \",\"\")\n",
    "df_natural['Identification Document Number_pre'] = df_natural['Identification Document Number_pre'].str.replace(\",\",\"\")\n",
    "df_natural['Identification Document Number_pre'] = df_natural['Identification Document Number_pre'].str.lower()\n",
    "\n",
    "# beneficiary only list\n",
    "bene_only = df_natural.groupby('Party ID')['Relationship (Party Role)'].agg(set).reset_index(name='role_set')\n",
    "bene_only = bene_only[bene_only['role_set']=={'Beneficiary'}]\n",
    "bene_only_list = bene_only['Party ID'].to_list()\n",
    "df_natural['bene_only'] = df_natural['Party ID'].isin(bene_only_list)\n",
    "\n",
    "#dates\n",
    "df_natural['Date of Birth']  = pd.to_datetime(df_natural['Date of Birth'], format='%Y-%m-%d', errors='coerce').dt.date"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "59dee730",
   "metadata": {},
   "source": [
    "### S24 - Duplicate parties"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "ebd368e5",
   "metadata": {},
   "outputs": [],
   "source": [
    "tab24 = df_natural.copy()\n",
    "\n",
    "#parties that hold at least 1 of these roles\n",
    "#if 'at least' then i probably need to move this section down until after the conditions\n",
    "\n",
    "\n",
    "# create concat column of same party name, DOB\n",
    "tab24_1 = tab24\n",
    "tab24_1['key'] = tab24_1['Party Name_pre'].astype(str) + tab24_1['Date of Birth'].astype(str)\n",
    "# add a column to count no. of Party ID based on same party name, DOB & Party RM\n",
    "tab24_1['unique_count'] = tab24_1.groupby(['key'])['Party ID'].transform('nunique')\n",
    "# keep only rows where theres > 1 Party ID \n",
    "tab24_1 = tab24_1[tab24_1['unique_count'] > 1]\n",
    "\n",
    "# create concat column of same party name, ID type, ID #\n",
    "tab24_2 = tab24\n",
    "tab24_2['key'] = tab24_2[\"Party Name_pre\"].astype(str) + tab24_2['Identification Document Type'].astype(str) + tab24_2['Identification Document Number'].astype(str)\n",
    "# add column to count no. of party ID based on key\n",
    "tab24_2['unique_count'] = tab24_2.groupby(['key'])['Party ID'].transform('nunique')\n",
    "# keep only rows where theres > 1 Party ID \n",
    "tab24_2 = tab24_2[tab24_2['unique_count'] > 1]\n",
    "\n",
    "# combine\n",
    "tab24_columns = pd.concat([tab24_1, tab24_2])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "3013daf9",
   "metadata": {},
   "outputs": [],
   "source": [
    "# include only parties that hold at least 1 operating role\n",
    "party_roles = {'Account Holder','Authorised Representative','General Power of Attorney','Limited Power of Attorney',\n",
    "               'Settlor or Asset Contributor','Founder','Policy Owner','Premium Payer','Subscriber'}\n",
    "\n",
    "# create a [Relationship (Party Role)] set for each group\n",
    "tab24_roles = tab24_columns.groupby('key')['Relationship (Party Role)'].agg(set).reset_index(name='role_set')\n",
    "role_set = tab24_roles.role_set.tolist()\n",
    "\n",
    "# function to check if role set does not contain any operating party roles\n",
    "def check_roles(role_set):\n",
    "    result = role_set.intersection(party_roles)\n",
    "    if len(result) == 0: return 'discard'\n",
    "    else: return result\n",
    "    \n",
    "tab24_roles['check_roles'] = tab24_roles['role_set'].apply(lambda x: check_roles(x))\n",
    "tab24_error = tab24_roles[tab24_roles['check_roles'] == 'discard'] #table of parties that do not have any operating roles\n",
    "tab24_keep = tab24_roles[tab24_roles['check_roles'] != 'discard'] #table of parties that have at least 1 operating role\n",
    "\n",
    "# compare keep list to original table\n",
    "tab24_keep_list = tab24_keep['key'].tolist()\n",
    "tab24_columns['exist'] = tab24_columns['key'].isin(tab24_keep_list)\n",
    "tab24_columns = tab24_columns[tab24_columns['exist']==True]\n",
    "\n",
    "# columns for set of all roles a party holds\n",
    "key_list = tab24_roles['key'].tolist()\n",
    "roles_list = tab24_roles['role_set'].tolist()\n",
    "roles_dict = {x:y for x,y in zip(key_list,roles_list)}\n",
    "tab24_columns['role_set'] = tab24_columns['key'].map(roles_dict)\n",
    "\n",
    "# state inconsistency type in new column 'Inconsistency'\n",
    "tab24_columns['Inconsistency'] = 'Duplicate Parties with at least 1 operating role'\n",
    "\n",
    "# remove duplicates\n",
    "tab24_columns = tab24_columns.drop_duplicates(subset=['Party ID', 'key'])\n",
    "tab24_columns = tab24_columns.sort_values(by=[\"key\",'Party ID'])\n",
    "\n",
    "# make numerical index\n",
    "tab24_index_list = sorted(list(set(tab24_columns['key'].tolist())))\n",
    "tab24_index_dict = {x:tab24_index_list.index(x)+1 for x in tab24_index_list}\n",
    "tab24_columns['Index'] = tab24_columns['key'].map(tab24_index_dict)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "5081194d",
   "metadata": {},
   "outputs": [],
   "source": [
    "tab24_columns = tab24_columns.drop(['Party Name_pre','Identification Document Number_pre',\n",
    "                                    'bene_only','unique_count','exist'], axis=1)\n",
    "\n",
    "# reordering and renaming columns\n",
    "new_index = ['Index','key','Relationship (Party Role)','role_set',\n",
    "             'Party ID','Party Name','Party Type','Date of Birth','Place of Birth','Identification Document Type',\n",
    "             'Identification Document Number','Identification Document Issue Country','Identification Document Expiry Date',\n",
    "             'Identification Date of Issue','Resident pass holder of','Address Type','Address - Country','Nationality','Booking Centre Officer',\n",
    "             'Countries of Business / Income Source for this Party','RM UID.1','RM Name.1','RM Location (Code)','RM Team Name.1','RM Market Name',\n",
    "             'Is Public','Vulnerable Client','Accredited Investor (AI) - Status','Override Expiry','Override Expiry Reason','Override Expiry Justification',\n",
    "             'Date of Incorporation','Business Registration No','Country of Incorporation','Booking Centre','Portfolio Number',\n",
    "             'Portfolio Name','Current Status','Relationship Type','Relationship Sub-Type','Category','Main Portfolio','Portfolio Creation Date',\n",
    "             'RM UID','RM Name','RM Location Name','RM Team Name','Market Name','Booking Center Officer Name','Managed By EAM / EIA / Finder',\n",
    "             'EAM / EIA Name','EAM / EIA Code','Finder Name','Finder Code','Collab Type','Incoming Channel','Collaboration Account Number',\n",
    "             'Consolidated Performance CCY','Asset Classification','Service Model','Staff Relationship',\n",
    "             'Inconsistency']\n",
    "output = tab24_columns.reindex(columns=new_index)\n",
    "output = output.rename(columns={'RM UID.1':'Party RM UID','RM Name.1':'Party RM Name','RM Team Name.1':'Party RM Team Name'})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "e185e3b9",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "output.to_csv(\"test.csv\", index=False)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
